/* Generated by re2c 0.9.7.rc2 on Thu Feb 16 06:11:08 2006 */
#line 1 "parser_lex.re"
/*
    Scripts sub-plugin for FARMail
    Copyright (C) 2002-2005 FARMail Group

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
#include "parser.hpp"
#include "scripts.hpp"
#include <stdio.h>

__INT64 Parser::GetValue(void)
{
  char *string=GetString();
  __INT64 result=0;
  if(string)
  {
    result=__ATOI(string);
    HeapFree(heap,0,string);
  }
  return result;
}

char *Parser::GetString(void)
{
  long len=yy_cursor-yy_token+1;
  char *result=(char *)HeapAlloc(heap,HEAP_ZERO_MEMORY,len);
  if(result)
    memcpy(result,yy_token,len-1); //memory zeroed so last simbol is zero.
  return result;
}

bool Parser::fill(int n)
{
  (void)n;
  if(!yy_eof)
  {
    DWORD transferred,tail_len=yy_limit-yy_token,skip_len=yy_token-yy_buffer;
    if((yy_buffer_size-tail_len)<n)
    {
      size_t add_len=n;
      if(add_len<yy_buffer_size) add_len=yy_buffer_size;
      YYCTYPE *yy_buffer_old=yy_buffer;
      yy_buffer=(YYCTYPE *)HeapReAlloc(heap,HEAP_ZERO_MEMORY,yy_buffer,yy_buffer_size+add_len);
      if(yy_buffer)
      {
        yy_buffer_size+=add_len;
        yy_token+=(yy_buffer-yy_buffer_old);
        yy_marker+=(yy_buffer-yy_buffer_old);
        yy_cursor+=(yy_buffer-yy_buffer_old);
        yy_limit+=(yy_buffer-yy_buffer_old);
        yy_linestart+=(yy_buffer-yy_buffer_old);
      }
      else
      {
        yy_buffer=yy_buffer_old;
        return false;
      }
    }
    memcpy(yy_buffer,yy_token,tail_len);
    yy_marker-=skip_len;
    yy_cursor-=skip_len;
    yy_limit-=skip_len;
    yy_linestart-=skip_len;
    yy_token=yy_buffer;
    if(ReadFile(file,yy_limit,yy_buffer_size-tail_len,&transferred,NULL)||(transferred=0,true))
    {
      if(transferred!=(yy_buffer_size-tail_len))
      {
        yy_eof=yy_limit+transferred;
        *(yy_eof)++='\n';
      }
      yy_limit+=transferred;
    }
  }
  return true;
}

#line 98 "parser_lex.re"


static inline int bcd2byte(int value)
{
  int res=value-0x30;
  if(res>9)
  {
    res-=7;
    if(res>15)
      res-=0x20;
  }
  return res;
}


int Parser::yylex(YYSTYPE *yylval)
{
  if(yy_cursor==yy_eof) return 0; //EOF
parse_clear:
  yy_col=yy_cursor-yy_linestart;
  if(yy_line_update)
  {
    yy_line_update=false;
    yy_line++;
  }
  yy_token=yy_cursor;
	static unsigned char yybm[] = {
	144, 144, 144, 144, 144, 144, 144, 144, 
	144, 152,   0, 152, 152, 152, 144, 144, 
	144, 144, 144, 144, 144, 144, 144, 144, 
	144, 144, 144, 144, 144, 144, 144, 144, 
	152, 144, 128, 144, 144, 144, 144, 144, 
	144, 144, 144, 144, 144, 144, 144, 144, 
	240, 240, 240, 240, 240, 240, 240, 240, 
	240, 240, 144, 144, 144, 144, 144, 144, 
	144, 176, 176, 176, 176, 176, 176, 176, 
	176, 176, 176, 176, 176, 176, 176, 176, 
	176, 176, 176, 176, 176, 176, 176, 176, 
	176, 176, 176, 144, 128, 144, 144, 176, 
	144, 176, 176, 176, 176, 176, 176, 176, 
	176, 176, 176, 176, 176, 176, 176, 176, 
	176, 176, 176, 176, 176, 176, 176, 176, 
	176, 176, 176, 144, 144, 144, 144, 144, 
	144, 144, 144, 144, 144, 144, 144, 144, 
	144, 144, 144, 144, 144, 144, 144, 144, 
	144, 144, 144, 144, 144, 144, 144, 144, 
	144, 144, 144, 144, 144, 144, 144, 144, 
	144, 144, 144, 144, 144, 144, 144, 144, 
	144, 144, 144, 144, 144, 144, 144, 144, 
	144, 144, 144, 144, 144, 144, 144, 144, 
	144, 144, 144, 144, 144, 144, 144, 144, 
	144, 144, 144, 144, 144, 144, 144, 144, 
	144, 144, 144, 144, 144, 144, 144, 144, 
	144, 144, 144, 144, 144, 144, 144, 144, 
	144, 144, 144, 144, 144, 144, 144, 144, 
	144, 144, 144, 144, 144, 144, 144, 144, 
	144, 144, 144, 144, 144, 144, 144, 144, 
	144, 144, 144, 144, 144, 144, 144, 144, 
	144, 144, 144, 144, 144, 144, 144, 144, 
	};

#line 41 "<stdout>"
{
	YYCTYPE yych;
	unsigned int yyaccept;
	goto yy0;
	++YYCURSOR;
yy0:
	if((YYLIMIT - YYCURSOR) < 9) YYFILL(9);
	yych = *YYCURSOR;
	switch(yych){
	case 0x09:	case 0x0B:
	case 0x0C:
	case 0x0D:	case ' ':	goto yy29;
	case 0x0A:	goto yy31;
	case '!':	goto yy23;
	case '"':	goto yy17;
	case '&':	goto yy25;
	case '\'':	goto yy8;
	case '+':	goto yy27;
	case '-':	goto yy28;
	case '/':	goto yy4;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy6;
	case '<':	goto yy20;
	case '=':	goto yy22;
	case '>':	goto yy18;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':	case '_':	case 'a':	case 'd':	case 'f':	case 'h':	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':	case 't':
	case 'u':
	case 'v':	case 'x':
	case 'y':
	case 'z':	goto yy16;
	case 'b':	goto yy12;
	case 'c':	goto yy13;
	case 'e':	goto yy10;
	case 'g':	goto yy14;
	case 'i':	goto yy9;
	case 'r':	goto yy2;
	case 's':	goto yy15;
	case 'w':	goto yy11;
	case '|':	goto yy26;
	default:	goto yy33;
	}
yy2:	++YYCURSOR;
	if((yych = *YYCURSOR) == 'e')	goto yy121;
	goto yy63;
yy3:
#line 181 "parser_lex.re"
{
    int res=_FUNC;
    char *name=GetString();
    yylval->variable=functions.IndexOf(name);
    if(yylval->variable<0)
    {
      res=_VAR;
      yylval->variable=symbols.IndexOf(name);
      if(yylval->variable<0)
      {
        if(symbols.Add(name))
          yylval->variable=symbols.GetCount()-1;
      }
    }
    if(name) HeapFree(heap,0,name);
    return res;
  }
#line 145 "<stdout>"
yy4:	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych == '*')	goto yy115;
	if(yych == '/')	goto yy117;
	goto yy5;
yy5:
#line 277 "parser_lex.re"
{
    if(!(*yy_token)) return ' ';
    return *yy_token;
  }
#line 157 "<stdout>"
yy6:	++YYCURSOR;
	yych = *YYCURSOR;
	goto yy114;
yy7:
#line 129 "parser_lex.re"
{
    yylval->number=GetValue();
    return _NUMBER;
  }
#line 166 "<stdout>"
yy8:	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych <= '&'){
		if(yych == 0x0A)	goto yy5;
		goto yy109;
	} else {
		if(yych <= '\'')	goto yy5;
		if(yych == '\\')	goto yy110;
		goto yy109;
	}
yy9:	yych = *++YYCURSOR;
	if(yych == 'f')	goto yy107;
	goto yy63;
yy10:	yych = *++YYCURSOR;
	if(yych == 'l')	goto yy94;
	if(yych == 'n')	goto yy95;
	goto yy63;
yy11:	yych = *++YYCURSOR;
	if(yych == 'e')	goto yy85;
	if(yych == 'h')	goto yy86;
	goto yy63;
yy12:	yych = *++YYCURSOR;
	if(yych == 'r')	goto yy80;
	goto yy63;
yy13:	yych = *++YYCURSOR;
	if(yych == 'o')	goto yy72;
	goto yy63;
yy14:	yych = *++YYCURSOR;
	if(yych == 'o')	goto yy67;
	goto yy63;
yy15:	yych = *++YYCURSOR;
	if(yych == 'u')	goto yy64;
	goto yy63;
yy16:	yych = *++YYCURSOR;
	goto yy63;
yy17:	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych == 0x0A)	goto yy5;
	goto yy53;
yy18:	++YYCURSOR;
	if((yych = *YYCURSOR) == '=')	goto yy50;
	goto yy19;
yy19:
#line 257 "parser_lex.re"
{ return _GT; }
#line 212 "<stdout>"
yy20:	++YYCURSOR;
	if((yych = *YYCURSOR) == '=')	goto yy48;
	goto yy21;
yy21:
#line 259 "parser_lex.re"
{ return _LT; }
#line 219 "<stdout>"
yy22:	yych = *++YYCURSOR;
	if(yych == '=')	goto yy46;
	goto yy5;
yy23:	++YYCURSOR;
	if((yych = *YYCURSOR) == '=')	goto yy44;
	goto yy24;
yy24:
#line 264 "parser_lex.re"
{ return _NOT; }
#line 229 "<stdout>"
yy25:	yych = *++YYCURSOR;
	if(yych == '&')	goto yy42;
	goto yy5;
yy26:	yych = *++YYCURSOR;
	if(yych == '|')	goto yy40;
	goto yy5;
yy27:	yych = *++YYCURSOR;
	if(yych == '+')	goto yy38;
	goto yy5;
yy28:	yych = *++YYCURSOR;
	if(yych == '-')	goto yy36;
	goto yy5;
yy29:	++YYCURSOR;
	yych = *YYCURSOR;
	goto yy35;
yy30:
#line 268 "parser_lex.re"
{ goto parse_clear; }
#line 247 "<stdout>"
yy31:	++YYCURSOR;
	goto yy32;
yy32:
#line 270 "parser_lex.re"
{
    yy_linestart=yy_cursor;
    yy_line_update=true;
    if(yy_col) yy_col--;
    return *yy_token;
  }
#line 258 "<stdout>"
yy33:	yych = *++YYCURSOR;
	goto yy5;
yy34:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy35;
yy35:	if(yybm[0+yych] & 8) {
		goto yy34;
	}
	goto yy30;
yy36:	++YYCURSOR;
	goto yy37;
yy37:
#line 266 "parser_lex.re"
{ return _DEC; }
#line 275 "<stdout>"
yy38:	++YYCURSOR;
	goto yy39;
yy39:
#line 265 "parser_lex.re"
{ return _INC; }
#line 281 "<stdout>"
yy40:	++YYCURSOR;
	goto yy41;
yy41:
#line 263 "parser_lex.re"
{ return _OR; }
#line 287 "<stdout>"
yy42:	++YYCURSOR;
	goto yy43;
yy43:
#line 262 "parser_lex.re"
{ return _AND; }
#line 293 "<stdout>"
yy44:	++YYCURSOR;
	goto yy45;
yy45:
#line 261 "parser_lex.re"
{ return _NE; }
#line 299 "<stdout>"
yy46:	++YYCURSOR;
	goto yy47;
yy47:
#line 260 "parser_lex.re"
{ return _EQ; }
#line 305 "<stdout>"
yy48:	++YYCURSOR;
	goto yy49;
yy49:
#line 258 "parser_lex.re"
{ return _LE; }
#line 311 "<stdout>"
yy50:	++YYCURSOR;
	goto yy51;
yy51:
#line 256 "parser_lex.re"
{ return _GE; }
#line 317 "<stdout>"
yy52:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy53;
yy53:	if(yybm[0+yych] & 16) {
		goto yy52;
	}
	if(yych <= '!')	goto yy54;
	if(yych <= '"')	goto yy56;
	goto yy55;
yy54:	YYCURSOR = YYMARKER;
	switch(yyaccept){
	case 1:	goto yy3;
	case 0:	goto yy5;
	}
yy55:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if(yych <= 'b'){
		if(yych <= '7'){
			if(yych <= '&'){
				if(yych == '"')	goto yy52;
				goto yy54;
			} else {
				if(yych <= '\'')	goto yy52;
				if(yych <= '/')	goto yy54;
				goto yy59;
			}
		} else {
			if(yych <= '['){
				if(yych == '?')	goto yy52;
				goto yy54;
			} else {
				if(yych <= '\\')	goto yy52;
				if(yych <= '`')	goto yy54;
				goto yy52;
			}
		}
	} else {
		if(yych <= 'r'){
			if(yych <= 'm'){
				if(yych == 'f')	goto yy52;
				goto yy54;
			} else {
				if(yych <= 'n')	goto yy52;
				if(yych <= 'q')	goto yy54;
				goto yy52;
			}
		} else {
			if(yych <= 'u'){
				if(yych == 't')	goto yy52;
				goto yy54;
			} else {
				if(yych <= 'v')	goto yy52;
				if(yych == 'x')	goto yy58;
				goto yy54;
			}
		}
	}
yy56:	++YYCURSOR;
	goto yy57;
yy57:
#line 199 "parser_lex.re"
{
    char *string=GetString(); size_t j=0;
    for(size_t i=1;i<(yy_cursor-yy_token-1);i++)
    {
      if(string[i]!='\\')
        string[j++]=string[i];
      else
      {
        if(string[++i]=='x')
        {
          int hex=bcd2byte(string[++i]);
          hex=hex*16+bcd2byte(string[++i]);
          string[j++]=hex;
        }
        else if(string[i]=='0'||string[i]=='1'||string[i]=='2'||string[i]=='3')
        {
          int oct=string[i]-'0';
          oct=oct*8+(string[++i]-'0');
          oct=oct*8+(string[++i]-'0');
          string[j++]=oct;
        }
        else
        {
          switch(string[i])
          {
            case 'a':
              string[j++]='\a';
              break;
            case 'b':
              string[j++]='\b';
              break;
            case 'f':
              string[j++]='\f';
              break;
            case 'n':
              string[j++]='\n';
              break;
            case 'r':
              string[j++]='\r';
              break;
            case 't':
              string[j++]='\t';
              break;
            case 'v':
              string[j++]='\v';
              break;
            default:
              string[j++]=string[i];
              break;
          }
        }
      }
    }
    string[j]=0;
    yylval->string=string;
    return _STRING;
  }
#line 440 "<stdout>"
yy58:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if(yych <= '@'){
		if(yych <= '/')	goto yy54;
		if(yych <= '9')	goto yy61;
		goto yy54;
	} else {
		if(yych <= 'F')	goto yy61;
		if(yych <= '`')	goto yy54;
		if(yych <= 'f')	goto yy61;
		goto yy54;
	}
yy59:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if(yych <= '/')	goto yy54;
	if(yych >= '8')	goto yy54;
	goto yy60;
yy60:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if(yych <= '/')	goto yy54;
	if(yych <= '7')	goto yy52;
	goto yy54;
yy61:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if(yych <= '@'){
		if(yych <= '/')	goto yy54;
		if(yych <= '9')	goto yy52;
		goto yy54;
	} else {
		if(yych <= 'F')	goto yy52;
		if(yych <= '`')	goto yy54;
		if(yych <= 'f')	goto yy52;
		goto yy54;
	}
yy62:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy63;
yy63:	if(yybm[0+yych] & 32) {
		goto yy62;
	}
	goto yy3;
yy64:	yych = *++YYCURSOR;
	if(yych != 'b')	goto yy63;
	goto yy65;
yy65:	++YYCURSOR;
	if(yybm[0+(yych = *YYCURSOR)] & 32) {
		yych = *YYCURSOR;
		goto yy62;
	}
	goto yy66;
yy66:
#line 177 "parser_lex.re"
{ return _SUB; }
#line 503 "<stdout>"
yy67:	yych = *++YYCURSOR;
	if(yych != 's')	goto yy63;
	goto yy68;
yy68:	yych = *++YYCURSOR;
	if(yych != 'u')	goto yy63;
	goto yy69;
yy69:	yych = *++YYCURSOR;
	if(yych != 'b')	goto yy63;
	goto yy70;
yy70:	++YYCURSOR;
	if(yybm[0+(yych = *YYCURSOR)] & 32) {
		yych = *YYCURSOR;
		goto yy62;
	}
	goto yy71;
yy71:
#line 176 "parser_lex.re"
{ return _GOSUB; }
#line 521 "<stdout>"
yy72:	yych = *++YYCURSOR;
	if(yych != 'n')	goto yy63;
	goto yy73;
yy73:	yych = *++YYCURSOR;
	if(yych != 't')	goto yy63;
	goto yy74;
yy74:	yych = *++YYCURSOR;
	if(yych != 'i')	goto yy63;
	goto yy75;
yy75:	yych = *++YYCURSOR;
	if(yych != 'n')	goto yy63;
	goto yy76;
yy76:	yych = *++YYCURSOR;
	if(yych != 'u')	goto yy63;
	goto yy77;
yy77:	yych = *++YYCURSOR;
	if(yych != 'e')	goto yy63;
	goto yy78;
yy78:	++YYCURSOR;
	if(yybm[0+(yych = *YYCURSOR)] & 32) {
		yych = *YYCURSOR;
		goto yy62;
	}
	goto yy79;
yy79:
#line 175 "parser_lex.re"
{ return _CONTINUE; }
#line 548 "<stdout>"
yy80:	yych = *++YYCURSOR;
	if(yych != 'e')	goto yy63;
	goto yy81;
yy81:	yych = *++YYCURSOR;
	if(yych != 'a')	goto yy63;
	goto yy82;
yy82:	yych = *++YYCURSOR;
	if(yych != 'k')	goto yy63;
	goto yy83;
yy83:	++YYCURSOR;
	if(yybm[0+(yych = *YYCURSOR)] & 32) {
		yych = *YYCURSOR;
		goto yy62;
	}
	goto yy84;
yy84:
#line 174 "parser_lex.re"
{ return _BREAK; }
#line 566 "<stdout>"
yy85:	yych = *++YYCURSOR;
	if(yych == 'n')	goto yy91;
	goto yy63;
yy86:	yych = *++YYCURSOR;
	if(yych != 'i')	goto yy63;
	goto yy87;
yy87:	yych = *++YYCURSOR;
	if(yych != 'l')	goto yy63;
	goto yy88;
yy88:	yych = *++YYCURSOR;
	if(yych != 'e')	goto yy63;
	goto yy89;
yy89:	++YYCURSOR;
	if(yybm[0+(yych = *YYCURSOR)] & 32) {
		yych = *YYCURSOR;
		goto yy62;
	}
	goto yy90;
yy90:
#line 172 "parser_lex.re"
{ return _WHILE; }
#line 587 "<stdout>"
yy91:	yych = *++YYCURSOR;
	if(yych != 'd')	goto yy63;
	goto yy92;
yy92:	++YYCURSOR;
	if(yybm[0+(yych = *YYCURSOR)] & 32) {
		yych = *YYCURSOR;
		goto yy62;
	}
	goto yy93;
yy93:
#line 173 "parser_lex.re"
{ return _WEND; }
#line 599 "<stdout>"
yy94:	yych = *++YYCURSOR;
	if(yych == 's')	goto yy104;
	goto yy63;
yy95:	yych = *++YYCURSOR;
	if(yych != 'd')	goto yy63;
	goto yy96;
yy96:	yych = *++YYCURSOR;
	if(yych == 'i')	goto yy97;
	if(yych == 's')	goto yy98;
	goto yy63;
yy97:	yych = *++YYCURSOR;
	if(yych == 'f')	goto yy102;
	goto yy63;
yy98:	yych = *++YYCURSOR;
	if(yych != 'u')	goto yy63;
	goto yy99;
yy99:	yych = *++YYCURSOR;
	if(yych != 'b')	goto yy63;
	goto yy100;
yy100:	++YYCURSOR;
	if(yybm[0+(yych = *YYCURSOR)] & 32) {
		yych = *YYCURSOR;
		goto yy62;
	}
	goto yy101;
yy101:
#line 178 "parser_lex.re"
{ return _ENDSUB; }
#line 627 "<stdout>"
yy102:	++YYCURSOR;
	if(yybm[0+(yych = *YYCURSOR)] & 32) {
		yych = *YYCURSOR;
		goto yy62;
	}
	goto yy103;
yy103:
#line 171 "parser_lex.re"
{ return _ENDIF; }
#line 636 "<stdout>"
yy104:	yych = *++YYCURSOR;
	if(yych != 'e')	goto yy63;
	goto yy105;
yy105:	++YYCURSOR;
	if(yybm[0+(yych = *YYCURSOR)] & 32) {
		yych = *YYCURSOR;
		goto yy62;
	}
	goto yy106;
yy106:
#line 170 "parser_lex.re"
{ return _ELSE; }
#line 648 "<stdout>"
yy107:	++YYCURSOR;
	if(yybm[0+(yych = *YYCURSOR)] & 32) {
		yych = *YYCURSOR;
		goto yy62;
	}
	goto yy108;
yy108:
#line 169 "parser_lex.re"
{ return _IF; }
#line 657 "<stdout>"
yy109:	yych = *++YYCURSOR;
	if(yych == '\'')	goto yy111;
	goto yy54;
yy110:	yych = *++YYCURSOR;
	if(yych <= 'b'){
		if(yych <= '>'){
			if(yych <= '"'){
				if(yych <= '!')	goto yy54;
				goto yy109;
			} else {
				if(yych == '\'')	goto yy109;
				goto yy54;
			}
		} else {
			if(yych <= '['){
				if(yych <= '?')	goto yy109;
				goto yy54;
			} else {
				if(yych <= '\\')	goto yy109;
				if(yych <= '`')	goto yy54;
				goto yy109;
			}
		}
	} else {
		if(yych <= 'q'){
			if(yych <= 'f'){
				if(yych <= 'e')	goto yy54;
				goto yy109;
			} else {
				if(yych == 'n')	goto yy109;
				goto yy54;
			}
		} else {
			if(yych <= 't'){
				if(yych == 's')	goto yy54;
				goto yy109;
			} else {
				if(yych == 'v')	goto yy109;
				goto yy54;
			}
		}
	}
yy111:	++YYCURSOR;
	goto yy112;
yy112:
#line 134 "parser_lex.re"
{
    if(yy_token[1]!='\\')
      yylval->number=yy_token[1];
    else
    {
      switch(yy_token[2])
      {
        case 'a':
          yylval->number='\a';
          break;
        case 'b':
          yylval->number='\b';
          break;
        case 'f':
          yylval->number='\f';
          break;
        case 'n':
          yylval->number='\n';
          break;
        case 'r':
          yylval->number='\r';
          break;
        case 't':
          yylval->number='\t';
          break;
        case 'v':
          yylval->number='\v';
          break;
        default:
          yylval->number=yy_token[2];
          break;
      }
    }
    return _NUMBER;
  }
#line 739 "<stdout>"
yy113:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy114;
yy114:	if(yybm[0+yych] & 64) {
		goto yy113;
	}
	goto yy7;
yy115:	++YYCURSOR;
	goto yy116;
yy116:
#line 127 "parser_lex.re"
{ goto parse_comment; }
#line 754 "<stdout>"
yy117:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy118;
yy118:	if(yybm[0+yych] & 128) {
		goto yy117;
	}
	goto yy119;
yy119:	++YYCURSOR;
	goto yy120;
yy120:	YYCURSOR -= 1;
#line 126 "parser_lex.re"
{ goto parse_clear; }
#line 769 "<stdout>"
yy121:	yych = *++YYCURSOR;
	if(yych != 'm')	goto yy63;
	goto yy122;
yy122:	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yybm[0+yych] & 32) {
		goto yy62;
	}
	if(yych == 0x09)	goto yy123;
	if(yych != ' ')	goto yy3;
	goto yy123;
yy123:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy124;
yy124:	if(yych != 0x0A)	goto yy123;
	goto yy125;
yy125:	++YYCURSOR;
	goto yy126;
yy126:	YYCURSOR -= 1;
#line 125 "parser_lex.re"
{ goto parse_clear; }
#line 793 "<stdout>"
}
#line 281 "parser_lex.re"

parse_comment:
  yy_token=yy_cursor;

#line 797 "<stdout>"
{
	YYCTYPE yych;
	goto yy127;
	++YYCURSOR;
yy127:
	if((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	if(yych == 0x0A)	goto yy131;
	if(yych != '*')	goto yy133;
	goto yy129;
yy129:	++YYCURSOR;
	if((yych = *YYCURSOR) == '/')	goto yy134;
	goto yy130;
yy130:
#line 293 "parser_lex.re"
{ goto parse_comment; }
#line 814 "<stdout>"
yy131:	++YYCURSOR;
	goto yy132;
yy132:
#line 287 "parser_lex.re"
{
    yy_linestart=yy_cursor;
    yy_line++;
    if(yy_cursor==yy_eof) return 0; //EOF
    goto parse_comment;
  }
#line 825 "<stdout>"
yy133:	yych = *++YYCURSOR;
	goto yy130;
yy134:	++YYCURSOR;
	goto yy135;
yy135:
#line 285 "parser_lex.re"
{ goto parse_clear; }
#line 833 "<stdout>"
}
#line 294 "parser_lex.re"

}
