/* Generated by re2c 0.13.1 on Sun May 25 03:27:35 2008 */
#line 1 "parser_lex.re"
/*
    Scripts sub-plugin for FARMail
    Copyright (C) 2002-2005 FARMail Group

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
#include "parser.hpp"
#include "scripts.hpp"
#include <stdio.h>

__INT64 Parser::GetValue(void)
{
  char *string=GetString();
  __INT64 result=0;
  if(string)
  {
    result=__ATOI(string);
    HeapFree(heap,0,string);
  }
  return result;
}

char *Parser::GetString(void)
{
  long len=yy_cursor-yy_token+1;
  char *result=(char *)HeapAlloc(heap,HEAP_ZERO_MEMORY,len);
  if(result)
    memcpy(result,yy_token,len-1); //memory zeroed so last simbol is zero.
  return result;
}

bool Parser::fill(int n)
{
  (void)n;
  if(!yy_eof)
  {
    DWORD transferred,tail_len=yy_limit-yy_token,skip_len=yy_token-yy_buffer;
    if((yy_buffer_size-tail_len)<n)
    {
      size_t add_len=n;
      if(add_len<yy_buffer_size) add_len=yy_buffer_size;
      YYCTYPE *yy_buffer_old=yy_buffer;
      yy_buffer=(YYCTYPE *)HeapReAlloc(heap,HEAP_ZERO_MEMORY,yy_buffer,yy_buffer_size+add_len);
      if(yy_buffer)
      {
        yy_buffer_size+=add_len;
        yy_token+=(yy_buffer-yy_buffer_old);
        yy_marker+=(yy_buffer-yy_buffer_old);
        yy_ctx_marker+=(yy_buffer-yy_buffer_old);
        yy_cursor+=(yy_buffer-yy_buffer_old);
        yy_limit+=(yy_buffer-yy_buffer_old);
        yy_linestart+=(yy_buffer-yy_buffer_old);
      }
      else
      {
        yy_buffer=yy_buffer_old;
        return false;
      }
    }
    memcpy(yy_buffer,yy_token,tail_len);
    yy_marker-=skip_len;
    yy_ctx_marker-=skip_len;
    yy_cursor-=skip_len;
    yy_limit-=skip_len;
    yy_linestart-=skip_len;
    yy_token=yy_buffer;
    if(ReadFile(file,yy_limit,yy_buffer_size-tail_len,&transferred,NULL)||(transferred=0,true))
    {
      if(transferred!=(yy_buffer_size-tail_len))
      {
        yy_eof=yy_limit+transferred;
        *(yy_eof)++='\n';
      }
      yy_limit+=transferred;
    }
  }
  return true;
}

#line 100 "parser_lex.re"


static inline int bcd2byte(int value)
{
  int res=value-0x30;
  if(res>9)
  {
    res-=7;
    if(res>15)
      res-=0x20;
  }
  return res;
}


int Parser::yylex(YYSTYPE *yylval)
{
  if(yy_cursor==yy_eof) return 0; //EOF
parse_clear:
  yy_col=yy_cursor-yy_linestart;
  if(yy_line_update)
  {
    yy_line_update=false;
    yy_line++;
  }
  yy_token=yy_cursor;

#line 123 "<stdout>"
{
	YYCTYPE yych;
	unsigned int yyaccept = 0;
	static const unsigned char yybm[] = {
		144, 144, 144, 144, 144, 144, 144, 144, 
		144, 152,   0, 152, 152, 152, 144, 144, 
		144, 144, 144, 144, 144, 144, 144, 144, 
		144, 144, 144, 144, 144, 144, 144, 144, 
		152, 144, 128, 144, 144, 144, 144, 144, 
		144, 144, 144, 144, 144, 144, 144, 144, 
		240, 240, 240, 240, 240, 240, 240, 240, 
		240, 240, 144, 144, 144, 144, 144, 144, 
		144, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 144, 128, 144, 144, 176, 
		144, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 144, 144, 144, 144, 144, 
		144, 144, 144, 144, 144, 144, 144, 144, 
		144, 144, 144, 144, 144, 144, 144, 144, 
		144, 144, 144, 144, 144, 144, 144, 144, 
		144, 144, 144, 144, 144, 144, 144, 144, 
		144, 144, 144, 144, 144, 144, 144, 144, 
		144, 144, 144, 144, 144, 144, 144, 144, 
		144, 144, 144, 144, 144, 144, 144, 144, 
		144, 144, 144, 144, 144, 144, 144, 144, 
		144, 144, 144, 144, 144, 144, 144, 144, 
		144, 144, 144, 144, 144, 144, 144, 144, 
		144, 144, 144, 144, 144, 144, 144, 144, 
		144, 144, 144, 144, 144, 144, 144, 144, 
		144, 144, 144, 144, 144, 144, 144, 144, 
		144, 144, 144, 144, 144, 144, 144, 144, 
		144, 144, 144, 144, 144, 144, 144, 144, 
		144, 144, 144, 144, 144, 144, 144, 144, 
	};

	if((YYLIMIT - YYCURSOR) < 9) YYFILL(9);
	yych = *YYCURSOR;
	switch(yych) {
	case 0x09:
	case 0x0B:
	case 0x0C:
	case 0x0D:
	case ' ':	goto yy29;
	case 0x0A:	goto yy31;
	case '!':	goto yy23;
	case '"':	goto yy17;
	case '&':	goto yy25;
	case '\'':	goto yy8;
	case '+':	goto yy27;
	case '-':	goto yy28;
	case '/':	goto yy4;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy6;
	case '<':	goto yy20;
	case '=':	goto yy22;
	case '>':	goto yy18;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'd':
	case 'f':
	case 'h':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 't':
	case 'u':
	case 'v':
	case 'x':
	case 'y':
	case 'z':	goto yy16;
	case 'b':	goto yy12;
	case 'c':	goto yy13;
	case 'e':	goto yy10;
	case 'g':	goto yy14;
	case 'i':	goto yy9;
	case 'r':	goto yy2;
	case 's':	goto yy15;
	case 'w':	goto yy11;
	case '|':	goto yy26;
	default:	goto yy33;
	}
yy2:
	++YYCURSOR;
	if((yych = *YYCURSOR) == 'e') goto yy121;
	goto yy63;
yy3:
#line 183 "parser_lex.re"
	{
    int res=_FUNC;
    char *name=GetString();
    yylval->variable=functions.IndexOf(name);
    if(yylval->variable<0)
    {
      res=_VAR;
      yylval->variable=symbols.IndexOf(name);
      if(yylval->variable<0)
      {
        if(symbols.Add(name))
          yylval->variable=symbols.GetCount()-1;
      }
    }
    if(name) HeapFree(heap,0,name);
    return res;
  }
#line 270 "<stdout>"
yy4:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych == '*') goto yy115;
	if(yych == '/') goto yy117;
yy5:
#line 279 "parser_lex.re"
	{
    if(!(*yy_token)) return ' ';
    return *yy_token;
  }
#line 282 "<stdout>"
yy6:
	++YYCURSOR;
	yych = *YYCURSOR;
	goto yy114;
yy7:
#line 131 "parser_lex.re"
	{
    yylval->number=GetValue();
    return _NUMBER;
  }
#line 293 "<stdout>"
yy8:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych <= '&') {
		if(yych == 0x0A) goto yy5;
		goto yy109;
	} else {
		if(yych <= '\'') goto yy5;
		if(yych == '\\') goto yy110;
		goto yy109;
	}
yy9:
	yych = *++YYCURSOR;
	if(yych == 'f') goto yy107;
	goto yy63;
yy10:
	yych = *++YYCURSOR;
	if(yych == 'l') goto yy94;
	if(yych == 'n') goto yy95;
	goto yy63;
yy11:
	yych = *++YYCURSOR;
	if(yych == 'e') goto yy85;
	if(yych == 'h') goto yy86;
	goto yy63;
yy12:
	yych = *++YYCURSOR;
	if(yych == 'r') goto yy80;
	goto yy63;
yy13:
	yych = *++YYCURSOR;
	if(yych == 'o') goto yy72;
	goto yy63;
yy14:
	yych = *++YYCURSOR;
	if(yych == 'o') goto yy67;
	goto yy63;
yy15:
	yych = *++YYCURSOR;
	if(yych == 'u') goto yy64;
	goto yy63;
yy16:
	yych = *++YYCURSOR;
	goto yy63;
yy17:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych == 0x0A) goto yy5;
	goto yy53;
yy18:
	++YYCURSOR;
	if((yych = *YYCURSOR) == '=') goto yy50;
#line 259 "parser_lex.re"
	{ return _GT; }
#line 348 "<stdout>"
yy20:
	++YYCURSOR;
	if((yych = *YYCURSOR) == '=') goto yy48;
#line 261 "parser_lex.re"
	{ return _LT; }
#line 354 "<stdout>"
yy22:
	yych = *++YYCURSOR;
	if(yych == '=') goto yy46;
	goto yy5;
yy23:
	++YYCURSOR;
	if((yych = *YYCURSOR) == '=') goto yy44;
#line 266 "parser_lex.re"
	{ return _NOT; }
#line 364 "<stdout>"
yy25:
	yych = *++YYCURSOR;
	if(yych == '&') goto yy42;
	goto yy5;
yy26:
	yych = *++YYCURSOR;
	if(yych == '|') goto yy40;
	goto yy5;
yy27:
	yych = *++YYCURSOR;
	if(yych == '+') goto yy38;
	goto yy5;
yy28:
	yych = *++YYCURSOR;
	if(yych == '-') goto yy36;
	goto yy5;
yy29:
	++YYCURSOR;
	yych = *YYCURSOR;
	goto yy35;
yy30:
#line 270 "parser_lex.re"
	{ goto parse_clear; }
#line 388 "<stdout>"
yy31:
	++YYCURSOR;
#line 272 "parser_lex.re"
	{
    yy_linestart=yy_cursor;
    yy_line_update=true;
    if(yy_col) yy_col--;
    return *yy_token;
  }
#line 398 "<stdout>"
yy33:
	yych = *++YYCURSOR;
	goto yy5;
yy34:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy35:
	if(yybm[0+yych] & 8) {
		goto yy34;
	}
	goto yy30;
yy36:
	++YYCURSOR;
#line 268 "parser_lex.re"
	{ return _DEC; }
#line 415 "<stdout>"
yy38:
	++YYCURSOR;
#line 267 "parser_lex.re"
	{ return _INC; }
#line 420 "<stdout>"
yy40:
	++YYCURSOR;
#line 265 "parser_lex.re"
	{ return _OR; }
#line 425 "<stdout>"
yy42:
	++YYCURSOR;
#line 264 "parser_lex.re"
	{ return _AND; }
#line 430 "<stdout>"
yy44:
	++YYCURSOR;
#line 263 "parser_lex.re"
	{ return _NE; }
#line 435 "<stdout>"
yy46:
	++YYCURSOR;
#line 262 "parser_lex.re"
	{ return _EQ; }
#line 440 "<stdout>"
yy48:
	++YYCURSOR;
#line 260 "parser_lex.re"
	{ return _LE; }
#line 445 "<stdout>"
yy50:
	++YYCURSOR;
#line 258 "parser_lex.re"
	{ return _GE; }
#line 450 "<stdout>"
yy52:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy53:
	if(yybm[0+yych] & 16) {
		goto yy52;
	}
	if(yych <= '!') goto yy54;
	if(yych <= '"') goto yy56;
	goto yy55;
yy54:
	YYCURSOR = YYMARKER;
	if(yyaccept <= 0) {
		goto yy5;
	} else {
		goto yy3;
	}
yy55:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if(yych <= 'b') {
		if(yych <= '7') {
			if(yych <= '&') {
				if(yych == '"') goto yy52;
				goto yy54;
			} else {
				if(yych <= '\'') goto yy52;
				if(yych <= '/') goto yy54;
				goto yy59;
			}
		} else {
			if(yych <= '[') {
				if(yych == '?') goto yy52;
				goto yy54;
			} else {
				if(yych <= '\\') goto yy52;
				if(yych <= '`') goto yy54;
				goto yy52;
			}
		}
	} else {
		if(yych <= 'r') {
			if(yych <= 'm') {
				if(yych == 'f') goto yy52;
				goto yy54;
			} else {
				if(yych <= 'n') goto yy52;
				if(yych <= 'q') goto yy54;
				goto yy52;
			}
		} else {
			if(yych <= 'u') {
				if(yych == 't') goto yy52;
				goto yy54;
			} else {
				if(yych <= 'v') goto yy52;
				if(yych == 'x') goto yy58;
				goto yy54;
			}
		}
	}
yy56:
	++YYCURSOR;
#line 201 "parser_lex.re"
	{
    char *string=GetString(); size_t j=0;
    for(size_t i=1;i<(yy_cursor-yy_token-1);i++)
    {
      if(string[i]!='\\')
        string[j++]=string[i];
      else
      {
        if(string[++i]=='x')
        {
          int hex=bcd2byte(string[++i]);
          hex=hex*16+bcd2byte(string[++i]);
          string[j++]=hex;
        }
        else if(string[i]=='0'||string[i]=='1'||string[i]=='2'||string[i]=='3')
        {
          int oct=string[i]-'0';
          oct=oct*8+(string[++i]-'0');
          oct=oct*8+(string[++i]-'0');
          string[j++]=oct;
        }
        else
        {
          switch(string[i])
          {
            case 'a':
              string[j++]='\a';
              break;
            case 'b':
              string[j++]='\b';
              break;
            case 'f':
              string[j++]='\f';
              break;
            case 'n':
              string[j++]='\n';
              break;
            case 'r':
              string[j++]='\r';
              break;
            case 't':
              string[j++]='\t';
              break;
            case 'v':
              string[j++]='\v';
              break;
            default:
              string[j++]=string[i];
              break;
          }
        }
      }
    }
    string[j]=0;
    yylval->string=string;
    return _STRING;
  }
#line 574 "<stdout>"
yy58:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if(yych <= '@') {
		if(yych <= '/') goto yy54;
		if(yych <= '9') goto yy61;
		goto yy54;
	} else {
		if(yych <= 'F') goto yy61;
		if(yych <= '`') goto yy54;
		if(yych <= 'f') goto yy61;
		goto yy54;
	}
yy59:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if(yych <= '/') goto yy54;
	if(yych >= '8') goto yy54;
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if(yych <= '/') goto yy54;
	if(yych <= '7') goto yy52;
	goto yy54;
yy61:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if(yych <= '@') {
		if(yych <= '/') goto yy54;
		if(yych <= '9') goto yy52;
		goto yy54;
	} else {
		if(yych <= 'F') goto yy52;
		if(yych <= '`') goto yy54;
		if(yych <= 'f') goto yy52;
		goto yy54;
	}
yy62:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy63:
	if(yybm[0+yych] & 32) {
		goto yy62;
	}
	goto yy3;
yy64:
	yych = *++YYCURSOR;
	if(yych != 'b') goto yy63;
	++YYCURSOR;
	if(yybm[0+(yych = *YYCURSOR)] & 32) {
		goto yy62;
	}
#line 179 "parser_lex.re"
	{ return _SUB; }
#line 633 "<stdout>"
yy67:
	yych = *++YYCURSOR;
	if(yych != 's') goto yy63;
	yych = *++YYCURSOR;
	if(yych != 'u') goto yy63;
	yych = *++YYCURSOR;
	if(yych != 'b') goto yy63;
	++YYCURSOR;
	if(yybm[0+(yych = *YYCURSOR)] & 32) {
		goto yy62;
	}
#line 178 "parser_lex.re"
	{ return _GOSUB; }
#line 647 "<stdout>"
yy72:
	yych = *++YYCURSOR;
	if(yych != 'n') goto yy63;
	yych = *++YYCURSOR;
	if(yych != 't') goto yy63;
	yych = *++YYCURSOR;
	if(yych != 'i') goto yy63;
	yych = *++YYCURSOR;
	if(yych != 'n') goto yy63;
	yych = *++YYCURSOR;
	if(yych != 'u') goto yy63;
	yych = *++YYCURSOR;
	if(yych != 'e') goto yy63;
	++YYCURSOR;
	if(yybm[0+(yych = *YYCURSOR)] & 32) {
		goto yy62;
	}
#line 177 "parser_lex.re"
	{ return _CONTINUE; }
#line 667 "<stdout>"
yy80:
	yych = *++YYCURSOR;
	if(yych != 'e') goto yy63;
	yych = *++YYCURSOR;
	if(yych != 'a') goto yy63;
	yych = *++YYCURSOR;
	if(yych != 'k') goto yy63;
	++YYCURSOR;
	if(yybm[0+(yych = *YYCURSOR)] & 32) {
		goto yy62;
	}
#line 176 "parser_lex.re"
	{ return _BREAK; }
#line 681 "<stdout>"
yy85:
	yych = *++YYCURSOR;
	if(yych == 'n') goto yy91;
	goto yy63;
yy86:
	yych = *++YYCURSOR;
	if(yych != 'i') goto yy63;
	yych = *++YYCURSOR;
	if(yych != 'l') goto yy63;
	yych = *++YYCURSOR;
	if(yych != 'e') goto yy63;
	++YYCURSOR;
	if(yybm[0+(yych = *YYCURSOR)] & 32) {
		goto yy62;
	}
#line 174 "parser_lex.re"
	{ return _WHILE; }
#line 699 "<stdout>"
yy91:
	yych = *++YYCURSOR;
	if(yych != 'd') goto yy63;
	++YYCURSOR;
	if(yybm[0+(yych = *YYCURSOR)] & 32) {
		goto yy62;
	}
#line 175 "parser_lex.re"
	{ return _WEND; }
#line 709 "<stdout>"
yy94:
	yych = *++YYCURSOR;
	if(yych == 's') goto yy104;
	goto yy63;
yy95:
	yych = *++YYCURSOR;
	if(yych != 'd') goto yy63;
	yych = *++YYCURSOR;
	if(yych == 'i') goto yy97;
	if(yych == 's') goto yy98;
	goto yy63;
yy97:
	yych = *++YYCURSOR;
	if(yych == 'f') goto yy102;
	goto yy63;
yy98:
	yych = *++YYCURSOR;
	if(yych != 'u') goto yy63;
	yych = *++YYCURSOR;
	if(yych != 'b') goto yy63;
	++YYCURSOR;
	if(yybm[0+(yych = *YYCURSOR)] & 32) {
		goto yy62;
	}
#line 180 "parser_lex.re"
	{ return _ENDSUB; }
#line 736 "<stdout>"
yy102:
	++YYCURSOR;
	if(yybm[0+(yych = *YYCURSOR)] & 32) {
		goto yy62;
	}
#line 173 "parser_lex.re"
	{ return _ENDIF; }
#line 744 "<stdout>"
yy104:
	yych = *++YYCURSOR;
	if(yych != 'e') goto yy63;
	++YYCURSOR;
	if(yybm[0+(yych = *YYCURSOR)] & 32) {
		goto yy62;
	}
#line 172 "parser_lex.re"
	{ return _ELSE; }
#line 754 "<stdout>"
yy107:
	++YYCURSOR;
	if(yybm[0+(yych = *YYCURSOR)] & 32) {
		goto yy62;
	}
#line 171 "parser_lex.re"
	{ return _IF; }
#line 762 "<stdout>"
yy109:
	yych = *++YYCURSOR;
	if(yych == '\'') goto yy111;
	goto yy54;
yy110:
	yych = *++YYCURSOR;
	if(yych <= 'b') {
		if(yych <= '>') {
			if(yych <= '"') {
				if(yych <= '!') goto yy54;
				goto yy109;
			} else {
				if(yych == '\'') goto yy109;
				goto yy54;
			}
		} else {
			if(yych <= '[') {
				if(yych <= '?') goto yy109;
				goto yy54;
			} else {
				if(yych <= '\\') goto yy109;
				if(yych <= '`') goto yy54;
				goto yy109;
			}
		}
	} else {
		if(yych <= 'q') {
			if(yych <= 'f') {
				if(yych <= 'e') goto yy54;
				goto yy109;
			} else {
				if(yych == 'n') goto yy109;
				goto yy54;
			}
		} else {
			if(yych <= 't') {
				if(yych == 's') goto yy54;
				goto yy109;
			} else {
				if(yych == 'v') goto yy109;
				goto yy54;
			}
		}
	}
yy111:
	++YYCURSOR;
#line 136 "parser_lex.re"
	{
    if(yy_token[1]!='\\')
      yylval->number=yy_token[1];
    else
    {
      switch(yy_token[2])
      {
        case 'a':
          yylval->number='\a';
          break;
        case 'b':
          yylval->number='\b';
          break;
        case 'f':
          yylval->number='\f';
          break;
        case 'n':
          yylval->number='\n';
          break;
        case 'r':
          yylval->number='\r';
          break;
        case 't':
          yylval->number='\t';
          break;
        case 'v':
          yylval->number='\v';
          break;
        default:
          yylval->number=yy_token[2];
          break;
      }
    }
    return _NUMBER;
  }
#line 845 "<stdout>"
yy113:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy114:
	if(yybm[0+yych] & 64) {
		goto yy113;
	}
	goto yy7;
yy115:
	++YYCURSOR;
#line 129 "parser_lex.re"
	{ goto parse_comment; }
#line 859 "<stdout>"
yy117:
	YYCTXMARKER = YYCURSOR + 1;
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if(yybm[0+yych] & 128) {
		goto yy117;
	}
	++YYCURSOR;
	YYCURSOR = YYCTXMARKER;
#line 128 "parser_lex.re"
	{ goto parse_clear; }
#line 872 "<stdout>"
yy121:
	yych = *++YYCURSOR;
	if(yych != 'm') goto yy63;
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yybm[0+yych] & 32) {
		goto yy62;
	}
	if(yych == 0x09) goto yy123;
	if(yych != ' ') goto yy3;
yy123:
	YYCTXMARKER = YYCURSOR + 1;
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if(yych != 0x0A) goto yy123;
	++YYCURSOR;
	YYCURSOR = YYCTXMARKER;
#line 127 "parser_lex.re"
	{ goto parse_clear; }
#line 893 "<stdout>"
}
#line 283 "parser_lex.re"

parse_comment:
  yy_token=yy_cursor;

#line 900 "<stdout>"
{
	YYCTYPE yych;
	if((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	if(yych == 0x0A) goto yy131;
	if(yych != '*') goto yy133;
	++YYCURSOR;
	if((yych = *YYCURSOR) == '/') goto yy134;
yy130:
#line 295 "parser_lex.re"
	{ goto parse_comment; }
#line 912 "<stdout>"
yy131:
	++YYCURSOR;
#line 289 "parser_lex.re"
	{
    yy_linestart=yy_cursor;
    yy_line++;
    if(yy_cursor==yy_eof) return 0; //EOF
    goto parse_comment;
  }
#line 922 "<stdout>"
yy133:
	yych = *++YYCURSOR;
	goto yy130;
yy134:
	++YYCURSOR;
#line 287 "parser_lex.re"
	{ goto parse_clear; }
#line 930 "<stdout>"
}
#line 296 "parser_lex.re"

}
